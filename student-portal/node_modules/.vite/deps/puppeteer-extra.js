import {
  require_browser,
  require_cjs
} from "./chunk-PZQAQ5IO.js";
import {
  __commonJS,
  __require,
  __toESM
} from "./chunk-OL46QLBJ.js";

// optional-peer-dep:__vite-optional-peer-dep:puppeteer:puppeteer-extra
var require_vite_optional_peer_dep_puppeteer_puppeteer_extra = __commonJS({
  "optional-peer-dep:__vite-optional-peer-dep:puppeteer:puppeteer-extra"() {
    throw new Error(`Could not resolve "puppeteer" imported by "puppeteer-extra". Is it installed?`);
  }
});

// optional-peer-dep:__vite-optional-peer-dep:puppeteer-core:puppeteer-extra
var require_vite_optional_peer_dep_puppeteer_core_puppeteer_extra = __commonJS({
  "optional-peer-dep:__vite-optional-peer-dep:puppeteer-core:puppeteer-extra"() {
    throw new Error(`Could not resolve "puppeteer-core" imported by "puppeteer-extra". Is it installed?`);
  }
});

// node_modules/puppeteer-extra/dist/index.esm.js
var import_debug = __toESM(require_browser());
var import_deepmerge = __toESM(require_cjs());
var debug = (0, import_debug.default)("puppeteer-extra");
var PuppeteerExtra = class {
  constructor(_pptr, _requireError) {
    this._pptr = _pptr;
    this._requireError = _requireError;
    this._plugins = [];
  }
  /**
   * The **main interface** to register `puppeteer-extra` plugins.
   *
   * @example
   * puppeteer.use(plugin1).use(plugin2)
   *
   * @see [PuppeteerExtraPlugin]
   *
   * @return The same `PuppeteerExtra` instance (for optional chaining)
   */
  use(plugin) {
    if (typeof plugin !== "object" || !plugin._isPuppeteerExtraPlugin) {
      console.error(`Warning: Plugin is not derived from PuppeteerExtraPlugin, ignoring.`, plugin);
      return this;
    }
    if (!plugin.name) {
      console.error(`Warning: Plugin with no name registering, ignoring.`, plugin);
      return this;
    }
    if (plugin.requirements.has("dataFromPlugins")) {
      plugin.getDataFromPlugins = this.getPluginData.bind(this);
    }
    plugin._register(Object.getPrototypeOf(plugin));
    this._plugins.push(plugin);
    debug("plugin registered", plugin.name);
    return this;
  }
  /**
   * To stay backwards compatible with puppeteer's (and our) default export after adding `addExtra`
   * we need to defer the check if we have a puppeteer instance to work with.
   * Otherwise we would throw even if the user intends to use their non-standard puppeteer implementation.
   *
   * @private
   */
  get pptr() {
    if (this._pptr) {
      return this._pptr;
    }
    console.warn(`
    Puppeteer is missing. :-)

    Note: puppeteer is a peer dependency of puppeteer-extra,
    which means you can install your own preferred version.

    - To get the latest stable version run: 'yarn add puppeteer' or 'npm i puppeteer'

    Alternatively:
    - To get puppeteer without the bundled Chromium browser install 'puppeteer-core'
    `);
    throw this._requireError || new Error("No puppeteer instance provided.");
  }
  /**
   * The method launches a browser instance with given arguments. The browser will be closed when the parent node.js process is closed.
   *
   * Augments the original `puppeteer.launch` method with plugin lifecycle methods.
   *
   * All registered plugins that have a `beforeLaunch` method will be called
   * in sequence to potentially update the `options` Object before launching the browser.
   *
   * @example
   * const browser = await puppeteer.launch({
   *   headless: false,
   *   defaultViewport: null
   * })
   *
   * @param options - See [puppeteer docs](https://github.com/puppeteer/puppeteer/blob/master/docs/api.md#puppeteerlaunchoptions).
   */
  async launch(options) {
    const defaultLaunchOptions = { args: [] };
    options = (0, import_deepmerge.default)(defaultLaunchOptions, options || {});
    this.resolvePluginDependencies();
    this.orderPlugins();
    options = await this.callPluginsWithValue("beforeLaunch", options);
    const opts = {
      context: "launch",
      options,
      defaultArgs: this.defaultArgs
    };
    this.checkPluginRequirements(opts);
    const browser = await this.pptr.launch(options);
    this._patchPageCreationMethods(browser);
    await this.callPlugins("_bindBrowserEvents", browser, opts);
    return browser;
  }
  /**
   * Attach Puppeteer to an existing Chromium instance.
   *
   * Augments the original `puppeteer.connect` method with plugin lifecycle methods.
   *
   * All registered plugins that have a `beforeConnect` method will be called
   * in sequence to potentially update the `options` Object before launching the browser.
   *
   * @param options - See [puppeteer docs](https://github.com/puppeteer/puppeteer/blob/master/docs/api.md#puppeteerconnectoptions).
   */
  async connect(options) {
    this.resolvePluginDependencies();
    this.orderPlugins();
    options = await this.callPluginsWithValue("beforeConnect", options);
    const opts = { context: "connect", options };
    this.checkPluginRequirements(opts);
    const browser = await this.pptr.connect(options);
    this._patchPageCreationMethods(browser);
    await this.callPlugins("_bindBrowserEvents", browser, opts);
    return browser;
  }
  /**
   * The default flags that Chromium will be launched with.
   *
   * @param options - See [puppeteer docs](https://github.com/puppeteer/puppeteer/blob/master/docs/api.md#puppeteerdefaultargsoptions).
   */
  defaultArgs(options) {
    return this.pptr.defaultArgs(options);
  }
  /** Path where Puppeteer expects to find bundled Chromium. */
  executablePath() {
    return this.pptr.executablePath();
  }
  /**
   * This methods attaches Puppeteer to an existing Chromium instance.
   *
   * @param options - See [puppeteer docs](https://github.com/puppeteer/puppeteer/blob/master/docs/api.md#puppeteercreatebrowserfetcheroptions).
   */
  createBrowserFetcher(options) {
    return this.pptr.createBrowserFetcher(options);
  }
  /**
   * Patch page creation methods (both regular and incognito contexts).
   *
   * Unfortunately it's possible that the `targetcreated` events are not triggered
   * early enough for listeners (e.g. plugins using `onPageCreated`) to be able to
   * modify the page instance (e.g. user-agent) before the browser request occurs.
   *
   * This only affects the first request of a newly created page target.
   *
   * As a workaround I've noticed that navigating to `about:blank` (again),
   * right after a page has been created reliably fixes this issue and adds
   * no noticable delay or side-effects.
   *
   * This problem is not specific to `puppeteer-extra` but default Puppeteer behaviour.
   *
   * Note: This patch only fixes explicitly created pages, implicitly created ones
   * (e.g. through `window.open`) are still subject to this issue. I didn't find a
   * reliable mitigation for implicitly created pages yet.
   *
   * Puppeteer issues:
   * https://github.com/GoogleChrome/puppeteer/issues/2669
   * https://github.com/puppeteer/puppeteer/issues/3667
   * https://github.com/GoogleChrome/puppeteer/issues/386#issuecomment-343059315
   * https://github.com/GoogleChrome/puppeteer/issues/1378#issue-273733905
   *
   * @private
   */
  _patchPageCreationMethods(browser) {
    if (!browser._createPageInContext) {
      debug("warning: _patchPageCreationMethods failed (no browser._createPageInContext)");
      return;
    }
    browser._createPageInContext = /* @__PURE__ */ function(originalMethod, context) {
      return async function() {
        const page = await originalMethod.apply(context, arguments);
        await page.goto("about:blank");
        return page;
      };
    }(browser._createPageInContext, browser);
  }
  /**
   * Get a list of all registered plugins.
   *
   * @member {Array<PuppeteerExtraPlugin>}
   */
  get plugins() {
    return this._plugins;
  }
  /**
   * Get the names of all registered plugins.
   *
   * @member {Array<string>}
   * @private
   */
  get pluginNames() {
    return this._plugins.map((p) => p.name);
  }
  /**
   * Collects the exposed `data` property of all registered plugins.
   * Will be reduced/flattened to a single array.
   *
   * Can be accessed by plugins that listed the `dataFromPlugins` requirement.
   *
   * Implemented mainly for plugins that need data from other plugins (e.g. `user-preferences`).
   *
   * @see [PuppeteerExtraPlugin]/data
   * @param name - Filter data by optional plugin name
   *
   * @private
   */
  getPluginData(name) {
    const data = this._plugins.map((p) => Array.isArray(p.data) ? p.data : [p.data]).reduce((acc, arr) => [...acc, ...arr], []);
    return name ? data.filter((d) => d.name === name) : data;
  }
  /**
   * Get all plugins that feature a given property/class method.
   *
   * @private
   */
  getPluginsByProp(prop) {
    return this._plugins.filter((plugin) => prop in plugin);
  }
  /**
   * Lightweight plugin dependency management to require plugins and code mods on demand.
   *
   * This uses the `dependencies` stanza (a `Set`) exposed by `puppeteer-extra` plugins.
   *
   * @todo Allow objects as depdencies that contains opts for the requested plugin.
   *
   * @private
   */
  resolvePluginDependencies() {
    const missingPlugins = this._plugins.map((p) => p._getMissingDependencies(this._plugins)).reduce((combined, list) => {
      return /* @__PURE__ */ new Set([...combined, ...list]);
    }, /* @__PURE__ */ new Set());
    if (!missingPlugins.size) {
      debug("no dependencies are missing");
      return;
    }
    debug("dependencies missing", missingPlugins);
    for (let name of [...missingPlugins]) {
      if (this.pluginNames.includes(name)) {
        debug(`ignoring dependency '${name}', which has been required already.`);
        continue;
      }
      name = name.startsWith("puppeteer-extra-plugin") ? name : `puppeteer-extra-plugin-${name}`;
      const packageName = name.split("/")[0];
      let dep = null;
      try {
        dep = __require(name)();
        this.use(dep);
      } catch (err) {
        console.warn(`
          A plugin listed '${name}' as dependency,
          which is currently missing. Please install it:

          yarn add ${packageName}

          Note: You don't need to require the plugin yourself,
          unless you want to modify it's default settings.
          `);
        throw err;
      }
      if (dep.dependencies.size) {
        this.resolvePluginDependencies();
      }
    }
  }
  /**
   * Order plugins that have expressed a special placement requirement.
   *
   * This is useful/necessary for e.g. plugins that depend on the data from other plugins.
   *
   * @todo Support more than 'runLast'.
   * @todo If there are multiple plugins defining 'runLast', sort them depending on who depends on whom. :D
   *
   * @private
   */
  orderPlugins() {
    debug("orderPlugins:before", this.pluginNames);
    const runLast = this._plugins.filter((p) => p.requirements.has("runLast")).map((p) => p.name);
    for (const name of runLast) {
      const index = this._plugins.findIndex((p) => p.name === name);
      this._plugins.push(this._plugins.splice(index, 1)[0]);
    }
    debug("orderPlugins:after", this.pluginNames);
  }
  /**
   * Lightweight plugin requirement checking.
   *
   * The main intent is to notify the user when a plugin won't work as expected.
   *
   * @todo This could be improved, e.g. be evaluated by the plugin base class.
   *
   * @private
   */
  checkPluginRequirements(opts = {}) {
    for (const plugin of this._plugins) {
      for (const requirement of plugin.requirements) {
        if (opts.context === "launch" && requirement === "headful" && opts.options.headless) {
          console.warn(`Warning: Plugin '${plugin.name}' is not supported in headless mode.`);
        }
        if (opts.context === "connect" && requirement === "launch") {
          console.warn(`Warning: Plugin '${plugin.name}' doesn't support puppeteer.connect().`);
        }
      }
    }
  }
  /**
   * Call plugins sequentially with the same values.
   * Plugins that expose the supplied property will be called.
   *
   * @param prop - The plugin property to call
   * @param values - Any number of values
   * @private
   */
  async callPlugins(prop, ...values) {
    for (const plugin of this.getPluginsByProp(prop)) {
      await plugin[prop].apply(plugin, values);
    }
  }
  /**
   * Call plugins sequentially and pass on a value (waterfall style).
   * Plugins that expose the supplied property will be called.
   *
   * The plugins can either modify the value or return an updated one.
   * Will return the latest, updated value which ran through all plugins.
   *
   * @param prop - The plugin property to call
   * @param value - Any value
   * @return The new updated value
   * @private
   */
  async callPluginsWithValue(prop, value) {
    for (const plugin of this.getPluginsByProp(prop)) {
      const newValue = await plugin[prop](value);
      if (newValue) {
        value = newValue;
      }
    }
    return value;
  }
};
var defaultExport = (() => {
  return new PuppeteerExtra(...requireVanillaPuppeteer());
})();
var addExtra = (puppeteer) => new PuppeteerExtra(puppeteer);
function requireVanillaPuppeteer() {
  try {
    return [require_vite_optional_peer_dep_puppeteer_puppeteer_extra(), void 0];
  } catch (_) {
  }
  try {
    return [require_vite_optional_peer_dep_puppeteer_core_puppeteer_extra(), void 0];
  } catch (err) {
    return [void 0, err];
  }
}
var index_esm_default = defaultExport;
export {
  PuppeteerExtra,
  addExtra,
  index_esm_default as default
};
/*! Bundled license information:

puppeteer-extra/dist/index.esm.js:
  (*!
   * puppeteer-extra v3.3.5 by berstend
   * https://github.com/berstend/puppeteer-extra
   * @license MIT
   *)
*/
//# sourceMappingURL=puppeteer-extra.js.map
